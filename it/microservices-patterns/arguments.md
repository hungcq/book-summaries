# Arguments
## Preface
- Enterprise applications are typically large monoliths (is it?)

## 1. Escaping monolithic hell
- Monolithic architecture:
    - <img src="../../resources/microservices-patterns/1.1.png" alt="drawing" width="500"/>
    - Suitable for new, small app
    - Benefits when the app is small:
        - Simple to dev: suitable for IDE & dev tools
        - Easy to make radical changes
        - Easy to test
        - Easy to deploy
        - Easy to scale
    - Drawbacks when the app is big:
        - Too complex -> difficult to dev & debug
        - Dev is slow: lag IDE, slow build, long start up time -> edit, build, run, test loop takes a long time
        - Path from commit to deployment is long:
            - Many devs -> hard to merge & need further testing
            - Complex -> need careful, system testing
        - Difficult to scale: conflicting resource requirements from dif modules
        - Not reliable:
            - Hard to test thoroughly
            - Lack of fault isolation
        - Locked into an obsolete tech stack: rewrite whole app is risky
- Software architecture mainly affect nonfunctional requirements (maintainability, extensibility, testability), not functional requirements
- 3 ways to scale an app:
    - Load balance requests across multiple instances:
        - Randomly
        - Based on request's attribute
    - Decompose by function into multiple services. Can be combined with load balancing.
- Microservice architecture:
    - <img src="....//resources/microservices-patterns/1.7.png" alt="drawing" width="500"/>
    - Suitable for large, complex app
    - -> Less about size, more about clear, focused responsibility for each service
    - Characteristics:
        - Loosely coupled services: services as unit of modularity, API as boundary
        - -> Easier to preserve modularity
        - Services communicate via APIs
        - Each service has its own database
    - Benefits: of small, independent services:
        - Enables the continuous delivery and deployment of large, complex apps (most imp benefit):
            - Testability
            - Deployability: usually don't require coordination
            - Autonomous, loosely coupled teams
        - Maintainability
        - Scalability: based on resource requirement of each service
        - Easy to experiment & adopt new techs
        - Reliability:
            - Better fault isolation
            - Easier to test
    - Drawbacks:
        - Difficult to find the right set of services
        - -> Can result in distributed monolith
        - Complex distributed system:
            - IPC
            - Partial failures
            - Transactions & queries spanning multiple services
            - Dev: not supported by IDE, hard to do automated testing multiple services
            - Operational complexity: management & deployment
        - -> Require sophisticated dev & operation skills
        - Need coordination when deploying features spanning many services
        - Difficult to decide when to adopt
          -> Many issues has multiple solutions, each with different set of tradeoffs
- Pattern:
    - Describe:
        - Issues
        - Result:
            - Benefit: solved issues
            - Drawback: unsolved issues
            - New issues
        - Related patterns
    - -> Objectivity -> better decision making
    - Can be organized into group: handle problems in a particular area
    - Pattern language: collection of related patterns that solve problems within a particular domain
- Microservice pattern language:
    - Software pattern: solves a software architecture or design problem by defining a set of collaborating software elements:
        - Object-oriented pattern: contains collaborating classes
        - High level design pattern: contains collaborating services
    - 3 layers:
        - Infra patterns: solve infra issues outside development
        - App infra patterns: solve infra issues related to development
        - App patterns: solve development problems
    - <img src="../../resources/microservices-patterns/1.10.png" alt="drawing" width="500"/>
    - Groups:
        - Decomposition:
        - <img src="../../resources/microservices-patterns/1.11.png" alt="drawing" width="500"/>
        - Communication:
        - <img src="../../resources/microservices-patterns/1.12.png" alt="drawing" width="500"/>
        - Data consistency:
        - <img src="../../resources/microservices-patterns/1.13.png" alt="drawing" width="500"/>
        - Data query:
        - <img src="../../resources/microservices-patterns/1.14.png" alt="drawing" width="500"/>
        - Deployment:
        - <img src="../../resources/microservices-patterns/1.15.png" alt="drawing" width="500"/>
        - Observability
        - Automated testing
        - Crosscutting concerns
        - Security
- Process & organization:
    - Imp for success, beside architecture
    - <img src="../../resources/microservices-patterns/1.16.png" alt="drawing" width="500"/>
    - Organization: team of teams, each 8-12 people
        - Each team has clear business-oriented goal:
          developing and possibly operating one or more services that implement a feature or a business capability
        - Cross-functional, can develop, test, and deploy its services without having to frequently communicate or coordinate with other teams
        - Grow: adding teams
    - -> Higher dev velocity, clear point of contact
    - Development & delivery process: agile dev & deployment practices (eg Scrum, Kanban)
    - Transition from monolithic to microservice architecture: need to consider reaction & emotion of people

## 2. Decomposition strategies
- Architectural view in 4+1 model: describes a particular aspect of the architecture
  - <img src="../../resources/microservices-patterns/2.1.png" alt="drawing" width="500"/>
- Architectural style:
  - Provide a limited set of elements (components) and relations (connectors) from which a **view** of an app's architecture can be defined
  - An app usually uses a combination of archi styles
  - Styles apply to the logical view:
    - Layered (eg 3-tier architecture)
    - Hexagonal:
      - Business logic at the center, has ports, interact with the outside via ports
      - <img src="../../resources/microservices-patterns/2.2.png" alt="drawing" width="500"/>
      - Port:
        - Defines a set of operations
        - Usually interface
        - Types:
          - Inbound: API exposed by business logic (eg service interface), allow it to be invoked by external apps
          - Outbound: define how business logic invoke external systems (eg repository interface)
      - Adapter types:
        - Inbound: handle outside requests by invoking business logic via inbound port (eg MVC controller)
        - Outbound: implements outbound port, invoked by business logic and invoke external apps (eg data access object DAO)
      - -> Adapters depend on business logic
      - Advs:
        - Decouple business logic from presentation & data access logic in the adapters
        - -> Easier to test business logic in isolation
        - Flexible, reflect modern app architecture: multiple, exchangeable adapters
        - Usage: design each service in a microservice archi
  - Styles apply to the implementation view:
    - Monolithic archi
    - Microservice archi:
      - Component: service:
        - With its own logical view archi (usually hexagonal) & potentially separate technology stack
        - Implementation view can take many form (see Chap 12)
        - Correspond to business capabilities
        - Has an API to provide client access to its functionality. API consists of:
            - Commands: perform action & update data
            - Queries: retrieve data
            - Events: published by service, consumed by its clients
        - Size of service is mostly unimportant:
          - Sign of well-designed service:
            - Can be developed by a small team with minimal lead time and collaboration with other teams
            - A team might only be responsible for a single service
          - Sign of badly designed service:
            - Requires a large team
            - Take a long time to test
            - Constantly need to change because of changes to other services or trigger changes in other services -> distributed monolith
      - Connector: communication protocol that services use to communicate, implemented using IPC mechanism
      - Key constraint: services are loosely coupled: all interactions with the service happen via its API
        - Restrict how services collaborate: not via DB
        - Advs:
          - Encapsulate implementation details -> can change without impacting clients
          - Improve app dev time attribute (eg understandability maintainability, testability)
          - Improve runtime isolation: can't lock DB of other services
      - Should only use shared libs for functionality that is unlikely to change
- Steps to define an app's microservice architecture:
  - Not a process to follow mechanically, but likely to be iterative and requires creativity
  - <img src="../../resources/microservices-patterns/2.5.png" alt="drawing" width="500"/>
  - Step 1: identify the system operations:
    - System operation def: abstraction of a request that the app must handle. Can be either:
      - Command: update data
      - Query: retrieve data
    - <img src="../../resources/microservices-patterns/2.6.png" alt="drawing" width="500"/>
    - Steps:
      - Create a high-level domain model: by analyzing the nouns in the user stories/scenarios and talking to domain experts
      - -> Result: domain models containing classes 
      - Define system operations:
        - <img src="../../resources/microservices-patterns/tab-2.1.png" alt="drawing" width="500"/>
        - Derive from verbs in user stories
        - Describe the operation's behavior in terms of effect on domain objects and their rela: create, update, delete domain objects; create/destroy rela between them
  - Step 2: define services by business capability:
    - Adv: business capabilities are stable -> resulting archi is stable
    - The resulting services are only the first attempt at defining the archi
    - -> May evolve over time as more is learned about the domain:
      - Combine services due to excessive IPC
      - Split services due to high complexity
    - Use domain driven design (DDD) as an alternative:
      - Domain def: app's problem space
      - Define a separate domain model for each subdomain -> service correspond to subdomain
      - Identify subdomain by business capability
    - Decomposition design issues:
      - Network latency: combine service to reduce IPC
      - Sync IPC reduces latency: use async messaging
      - Managing data consistency: distributed trans or saga
      - Obtain a consistent view of the data: rarely a problem in practice
      - God classes prevent decomposition: apply DDD and use a separate domain model for each service
      - -> Each service has its own domain model with its own version of the god class
  - Step 3: define service APIs: steps:
    - Assign system operations to services
    - Determine the APIs required to support collaboration between services for each system operation: independent of IPC technology

## 3. Interprocess communication in a microservice architecture
### IPC design issues:
- Interaction styles:
  - <img src="../../resources/microservices-patterns/tab-3.1.png" alt="drawing" width="500"/>
  - Mostly not related to IPC techs (eg can use messaging for req/res style by blocking waiting for a res)
- API definition: API-first design
  - Steps:
    - Write interface definition
    - Review it with client devs
  - -> Only implement the service after that
- Evolve API:
  - Use semantic versioning
  - Strive to make backward-compatible changes:
    - Add optional attributes to the request. Provide default values for missing attributes.
    - Add attributes to a response. Clients should ignore extra response attributes.
    - Add new operations
  - For major, breaking changes:
    - Embed the major version number in the URL (eg /v2/...)
    - Support old versions by putting version-translating logic in the service's *API adapter*
- Messaging formats:
  - Use cross-language message format
  - Types:
    - Text-based (eg JSON, XML):
      - Advs:
        - Readable by human
        - Self-describing
      - Disadv: big & costly-to-parse message
    - Binary: advs & disadvs: reverse of text-based. Additional advs:
      - Require API-first design
      - Can be statically checked in compiling languages
### Remote procedure call communication
- Characteristic: client assumes the res will arrive in a timely fashion
- Advs:
  - Familiar & easy to test
  - Simple architecture
- Disadvs:
  - Reduced availability
  - Clients need to know location of the service -> need service discovery
- Design issues:
  - Handle partial failure & protect caller:
    - Develop robust RPC proxies using:
      - Request timeout
      - Limit number of outstanding requests from a client to a service
      - Circuit breaker
    - Recover from an unavailable service:
      - Return error to client
      - Return a fallback value
      - Return cached data or omit the field from the response
  - Service discovery:
    - Why service discovery is needed: in modern, cloud-based microservices app:
      - Service instance have dynamically assigned network locations
      - Set of service instances changes dynamically because of autoscaling, failures & upgrades
    - Mechanism:
      - When service instances start and stop: update the *service registry*
      - When a client invokes a service: query the service registry to obtain a list of available service instances & routes the request to one of them
    - 2 types:
      - Application-level service discovery:
        - <img src="../../resources/microservices-patterns/3.5.png" alt="drawing" width="500"/>
        - Need health check mechanism
        - Client can cache service instances to improve performance
        - Adv: can handle scenario when services are deployed on multiple deployment platforms
        - Disadvs:
          - Need service discovery lib for every language/framework
          - Need to set up & manage the service registry
      - Platform-provided service discovery:
        - <img src="../../resources/microservices-patterns/3.6.png" alt="drawing" width="500"/>
        - Adv: all aspects of service discovery are handled by the deployment platform
        - -> Service discovery is available to all services and clients regardless of their language/framework
        - Disadv: only support discovery of services that have been deployed using the platform
### Async messaging communication
- <img src="../../resources/microservices-patterns/3.7.png" alt="drawing" width="500"/>
- 2 types of channels:
  - Point to point: 1 message consumed by only 1 of the consumers (eg same consumer group in Kafka)
  - Publish-subscribe
- Use messaging to implement dif interaction styles:
  - Req/res & req/async res:
    - <img src="../../resources/microservices-patterns/3.8.png" alt="drawing" width="500"/>
    - For sync req/res, client blocks until it receives the response
  - One-way noti & publish/subscribe: supported by messaging infra
  - Publish/async responses: similar to async req/res. Client gather responses with matching correlation ID.
- API definition:
  - Async operations API:
    - Req/async res:
      - Service's command mes channel
      - Types & formats of command message
      - Types & format of reply message
    - One-way noti:
      - Service's command mes channel
      - Types & formats of command message
  - Published events API:
    - Event channel
    - Types & formats of event messages
- 2 types of architecture:
  - Broker-less: direct communication, client doesn't wait for response:
    - Advs:
      - Of direct communication
      - No disadv of centralized broker
    - Disadvs:
      - Same as RPC
      - Hard to implement mechanisms such as guarantee delivery
  - Broker-based: use a message broker:
    - Main consideration when choosing message broker: message ordering & scalability
    - Advs:
      - Loose coupling: publisher don't need to be aware of consumers -> no need for service discovery
      - Message buffering -> increased availability
    - Disadvs:
      - Potential performance bottleneck/single point of failure
      - Additional operational complexity
- Design issues:
  - Competing receivers & message ordering: 
    - How to scale out receivers while preserve message ordering
    - How to process message concurrently in each consumer
  - -> Solution: sharded (partitioned) channels:
    - <img src="../../resources/microservices-patterns/3.11.png" alt="drawing" width="500"/>
    - Related messages -> same partition (eg partitioned by key)
    - n partition : 1 consumer service (eg same consumer group)
  - -> Same approach can be applied to multi threading handlers in each service
  - Handle duplicate messages:
    - Most mes broker deliver at least once
    - Duplicate example: crash before ack-ing
    - Solutions:
      - Write idempotent message handlers. Requirements:
        - Logic can be called multiple times with no additional effect
        - Message broker preserves ordering when redelivering messages
      - Track messages & discard duplicates:
        - Store processed message ids in dedicated table
        - Store processed message in app table (eg when using NoSQL DB with limited transaction model)
  - Transactional messaging:
    - Use distributed trans spanning the DB & the broker
    - -> Problem: many modern brokers don't support distributed trans
    - Use *transactional outbox pattern*:
      - <img src="../../resources/microservices-patterns/3.13.png" alt="drawing" width="500"/>
      - Publish message using *Polling publisher* or *Transaction log tailing* pattern
  - Choose lib:
    - Use broker's client lib: require effort to implement high level mechanisms
    - -> Should use higher level library/framework that support higher level interaction styles
- How to replace sync interaction to improve availability:
  - Use async interaction styles
  - -> Disadv: services often have external API that uses sync protocol (eg REST) -> must respond immediately
  - Replicate data:
    - Mechanism:
      - Maintain a replica of the needed data when processing requests
      - Subscribe to events publish by data owner to keep the replica up to date
    - Disadv: might require replication of large amount of data
  - Finish processing after returning a response:
    - Mechanism:
      - Respond to client immediately (eg in pending state)
      - Send confirmed state later
    - Disadv: require corresponding client flow/logic
### Additional info
- Factors to consider when choosing message broker:
  - Supported programming language
  - Supported messaging standard (eg AMQP, STOMP)
  - Message ordering
  - Delivery guarantees
  - Persistence
  - Durability: disconnected consumer can receive prev messages after reconnecting
  - Scalability
  - Latency
  - Competing consumers

## 4. Managing transactions with sagas
### Overview of transaction management in microservice architecture
- Characteristic: transactions span multiple services, each has its own database
- -> Need to maintain data consistency across the databases
- Disadvs of distributed transaction:
  - Not supported by many modern tech (Kafka, NoSQL), which usually choose availability over consistency
  - Reduced availability
- Saga:
  - Define one for each system command that updates data in multiple services
  - Mechanism:
    - The system operation initiates the first step of the saga
    - Completion of a local transaction triggers the execution of the next local transaction
  - Adv: high availability
  - Design issues:
    - Lack of isolation
    - Need to be able to roll back using compensating trans since each local trans commits its changes:
      - Approach: roll back the committed transactions in the reverse order
      - Types of trans & need to rollback:
        - Need compensating transaction: compensatable trans
        - Not required: read-only, pivot, retriable trans
  - Implementation: contain logic that coordinate the steps of the saga
### 2 ways to structure saga's coordination logic:
- Choreography: distribute decision making and sequencing among the saga participants
  - Main communication method: events
  - <img src="../../resources/microservices-patterns/4.4.png" alt="drawing" width="500"/>
  - Disadv: risk of interaction being too complex for complex saga
  - Usage: simple sagas
- Orchestration: centralize saga coordination logic in a saga orchestrator class
  - Mechanism: orchestrator sends command messages to saga participants telling them which operations to perform
  - <img src="../../resources/microservices-patterns/4.6.png" alt="drawing" width="500"/>
    - *Note*: Order service sends its own event to be consistent: saga treats Order service as just another participant
  - How to model the orchestrator: as state machine:
    - <img src="../../resources/microservices-patterns/4.7.png" alt="drawing" width="500"/>
    - Action: invoke a saga participant
    - Transition between states: triggered by completion of a local trans by a saga participant
    - -> Current state & outcome of local trans determine state transition & action to perform
    - Advs state machine:
      - Model dif scenarios for a saga
      - Can be tested effectively
  - Adv: ess complex interaction & coupling
  - Disadv: risk of centralizing too much business logic in the orchestrator
  - -> Need to design orchestrators that are solely responsible for sequencing & don't contain any other business logic
### Handle the lack of isolation in sagas
- Problem: updates made by each local trans, after committed, are immediately visible to other sagas
- Anomalies caused by lack of isolation:
  - Lost update
  - Dirty read
  - Non-repeatable read
- Type of saga transactions:
  - Compensatable: can be rolled back using a compensating trans
  - Pivot: if pivot trans commit, the saga will run until completion
  - Retriable: trans following pivot trans, guaranteed to succeed
- Countermeasures:
  - Semantic lock: a saga's compensatable trans sets a flag in any record that it creates or updates (eg in *state* field)
  - -> Need to decide how a saga should deal with a locked record:
    - Command returns error, client retry later -> easy to implement but complex client with retry logic
    - Command blocks until the lock is released -> serialized saga, easy to implement but have to manage locks & handle deadlocks
  - Commutative update: update operations can be executed in any order
  - Pessimistic view: reorder the steps of a saga to minimize business risk due to a dirty read (eg put update in retriable trans)
  - Reread value:
    - Reread a record before updating it, verify that it's unchanged, then updates the record
    - If the record has changed, the saga aborts & possibly restarts
  - Version file: record the operations that are performed on a record so that it can reorder them (eg already cancelled? -> won't update to *created* state)
  - By value: select concurrency mechanism (saga or distributed trans) based on business risk
### Saga code example: skipped

## 13. Refactoring to microservices
- Goal: refactor from monolith to microservices without having to rewrite app from scratch
### Overview of refactoring to microservices
- Consideration before refactoring: make sure business problems arise because of monolith architecture, not because of:
    - Poor software dev process (eg manual testing)
    - Not try all scalability solution
- Non-strategy: dev new microservices app from scratch. Reasons:
    - Lots of time wasted not implementing features that the business needs
    - New features still developed in the monolith -> effort diverted, constant moving target
    - Might implement features that are no longer needed
- Overall strat:
    - Incrementally refactor the monolith & build stranger app
    - -> Stop when the monolith is small enough/no longer an obstacle to ongoing dev
    - Migrate high value or constantly changing areas of the app first
    - -> Increase dev velocity, maintain business support for the migration
    - Avoid making widespread changes to the monolith
    - Avoid building deployment infra upfront: only need a deployment pipeline with automated testing
    - Reduce effort, have time to gain real exp to pick technologies
### Strategies for refactoring a monolith to microservices
- Implement new features as services:
    - Benefits:
        - Stop the monolith from growing
        - Accelerate dev of new features
        - Demonstrate business value
    - Need 2 other elements to integrate the new service into the app:
        - API gateway: to route request to service & monolith
        - Integration glue code:
            - Allow service to access the monolith data & invoke its functionality
            - Consist of adapters in the monolith & the service that communicate via IPC
        - <img src="../../resources/microservices-patterns/13.2.png" alt="drawing" width="500"/>
    - Non-usage:
        - New feature is too small to be a meaningful service
        - New feature is too tightly coupled with the monolith
        - -> Performance problem due to excessive IPC
        - Data consistency problem
    - -> Need to implement in the monolith, extract later
- Separate presentation tier from the backend:
    - <img src="../../resources/microservices-patterns/13.3.png" alt="drawing" width="500"/>
    - Benefits:
        - Dev, deploy & scale 2 apps independently
        - Expose remote API of monolith that can be called by new microservices
    - -> Only a partial solution
- Extract business capabilities into services:
    - <img src="../../resources/microservices-patterns/13.4.png" alt="drawing" width="500"/>
    - Parts to extract to the new service:
        - Inbound adapters containing API endpoints
        - Domain logic
        - Outbound adapters (eg DB access logic)
        - DB schema of the monolith
    - Likely to be time-consuming: monolith code base is likely to be messy
    - -> Need to decide which service to extract first
    - Might do over many iterations: each iteration extract several functionalities
    - Design issues:
        - How to split the domain model:
            - Remove object references:
                - Use aggregate concept
                - Avoid having large impact on clients of the class on the monolith: replicate data
            - Split class: extract functionality from a class that has other responsibilities
        - How to refactor the database: changing all clients of the DB to use the new schema takes lots of time
        - -> Solutions:
            - Migrate then replicate data from service back to monolith to avoid large impact
            - Migrate the clients incrementally (might not need to when client code is extracted into a new service)
        - What is the sequence of service extraction:
            - Design the new architecture -> revise it as you gain migration experience
            - Strats:
                - Freeze monolith dev/bug fix and extract services on demand:
                    - Adv: force you to break up the monolith
                    - Disadv: service extraction is driven by short-term requirements
                    - -> Risk of small benefit in exchange for lots of effort
                - Rank services by the benefit from extraction:
                    - Accelerates development: when business roadmap suggests lots of dev in such part
                    - Solve performance/scaling/reliability problem
                    - Enable extraction of other services
                - -> More strategic & closely align with business' needs
    - Design steps:
        - Review code related to the service business and identify participating entities & their fields
        - Decide which data to migrate to the service. Need to consider:
            - How monolith and service access each other's data
            - How to maintain data consistency
        - Design service domain logic: mostly copy code from the monolith
### Designing how the service and the monolith collaborate
- Design integration glue:
    - Design API that the glue provides to the domain logic: encapsulate in an interface:
        - Query API: Respository interface
        - Command API: Service interface:
            - Changes in the monolith to call the Service interface:
                - Identify all places in the monolith that invoke such business logic to call the interface
                - Implement the interface with:
                    - Existing monolith logic
                    - Proxy to new service
                - Use feature toggle to dynamically switch between the 2 implementations
                - Remove the existing monolith implementation when the service is considered working as expected
                - <img src="../../resources/microservices-patterns/13.23.png" alt="drawing" width="500"/>
    - Pick interaction style & IPC mechanism:
        - Query data:
            - Option 1: consumer invoke RPC API of data provider:
                - Adv: simple to implement
                - Disadv:
                    - Inefficient if consumer makes lots of requests
                    - Reduced availability
            - Option 2:
                - Provider is monolith: service implement CQRS
                - Provider is service: service publish domain events for monolith to consume and update its DB
                - Adv: efficient
                - Disadv:
                    - Increased complexity
                    - Might need to modify monolith to publish domain event
        - Update data: use transactional messaging
            - Transaction required: use saga
            - Transaction not required: publish event
    - Implement anti-corruption layer:
        - When:
            - Develop new domain model in the service, dif from monolith domain model
            - Need to communicate with monolith
        - Goal: prevent legacy monolith's domain model from polluting service's domain model
        - Anti corruption layer def: layer of code that translates between dif domain models
        - <img src="../../resources/microservices-patterns/13.11.png" alt="drawing" width="500"/>
        - Functions:
            - Map class/attribute names/values
            - Map status code
        - Where to implement:
            - In service:
                - When receive monolith domain event
                - When invoke monolith API
            - In monolith:
                - When subscribe to service event
                - When invoke service API
    - Publish/consume domain event in the monolith:
        - Publish:
            - Sol 1: in the code:
                - Adv: can publish high level domain event
                - Disadv:
                    - Need to locate all the places to publish. Potentially huge change.
                    - Can't deal with cases using stored procedure
            - Sol 2: use DB event via transaction log tailing/polling
                - Adv: don't have to change the monolith
                - Disadv:
                    - Low level event
                    - Don't know reason for the update
        - Consume problem: monolith written in language without message broker client
        - -> New helper service to subscribe to event & update monolith DB directly
- Maintain data consistency across service and monolith:
    - Problem: introducing saga's compensating transaction in the monolith might require numerous, risky code change (eg new "state" field in DB model)
    - Approach: ensure monolith transactions are either pivot or retriable transactions by:
        - Design saga
        - Decide service extraction order
- Handle authentication & authorization:
    - Problem: support both monolith and JWT-based security mechanisms simultaneously
    - Solution:
        - Monolith login handler returns an additional cookie to be included in every request. Cookie content: JWT token.
        - API gateway validate the token in the cookie, set it in authorization header and send to services
        - Services validate the token and extract info
        - <img src="../../resources/microservices-patterns/13.13.png" alt="drawing" width="500"/>
### Refactoring examples of strat 1 and 3: skipped
