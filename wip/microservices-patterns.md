# Category
IT, backend, microservices, architecture, development

# Summary
The author start by introducing the situations and the need to use microservice architecture.
Then he covers the problems you will face when developing microservices and the patterns to solve it.
Last part of the book handles the difficulty when transitioning from monolithic to microservice architecture.

# Structure
## Outline
- Preface:
  - History of microservice architecture
  - The problems & how they will be addressed in the book
  - Reason to organize the book around patterns
- Chap 1 & 2:
  - Basic concepts
  - Problem of monolithic, when and why to use microservice architecture
  - Advs & disadvs of microservice architecture
  - Microservice patterns as a solution
  - Defining application architecture:
    - Decompose & define services
    - Define APIs
- Chap 3-12: problems & patterns:
  - Interprocess communication
  - Managing transactions
  - Designing business logic
  - Implementing queries
  - Designing external APIs for various types of client
  - Automated testing for microservices
  - Developing production-ready services:
    - Security
    - Configuration
    - Observability
  - Deployment
- Chap 13: refactoring from monolithic to microservice architecture: difficulty & strategies

## Detailed structure
- Chap 1:
  - Monolithic architecture: usage, advs & disadvs
  - Role of software architecture
  - Microservice architecture: usage, characteristics, advs & disadvs
  - Pattern & pattern language: def, characteristics, advs
  - Microservice pattern language: def, 3 layers, pattern groups
  - Process & organization: when working with microservice architecture
- Chap 13:
  - Overview: consideration before refactoring, non-strat and overview of strangler strat
  - 3 main strangling strats: usage, advs, design issues:
    - Implement new features as services
    - Separate presentation tier and backend
    - Extract business capabilities into services
  - Design collaboration between service and monolith: architecture, design issues:
    - Design integration glue
    - Maintain data consistency
    - Handle authentication & authorization
  - Refactoring examples using strat 1 and 3

# Author's problems & solutions
- Discuss benefits & drawbacks of microservices, when to use microservices and when to use monolithic architecture
- Show how to adopt microservice architecture & develop microservices successfully:
  - Effective microservice testing
  - Microservice deployment
  - Refactoring strategies from monolith to microservice
  - How to design a microservice app: solutions to design challenges, including managing distributed data
  - How to develop business logic for a service
- Explain microservice architecture patterns & other concepts
- Make the material accessible regardless technology stack of the reader

# Presentation & style
- Organize around a collection of patterns

# Terms
- Pattern: reusable solution to a problem that occur in a particular context
- Microservice pattern language: collection of interrelated software architecture and design patterns for microservices
- List of microservice patterns:
  - Application architecture patterns:
    - Monolithic architecture: structure a system as a single executable or deployable component
    - Microservice architecture: functionally decompose an app into a set of services
  - Decomposition patterns:
    - Decompose by business capability (51)
    - Decompose by subdomain (54)
  - Messaging style patterns:
    - Messaging (85)
    - Remote procedure invocation (72)
  - Reliable communications patterns:
    - Circuit breaker (78)
  - Service discovery patterns:
    - 3rd party registration (85)
    - Client-side discovery (83)
    - Self-registration (82)
    - Server-side discovery (85)
  - Transactional messaging patterns:
    - Polling publisher (98)
    - Transaction log tailing (99)
    - Transactional outbox (98)
  - Data consistency patterns:
    - Saga (114)
  - Business logic design patterns:
    - Aggregate (150)
    - Domain event (160)
    - Domain model (150)
    - Event sourcing (184)
    - Transaction script (149)
  - Querying patterns:
    - API composition (223)
    - Command query responsibility segregation (228)
  - External API patterns:
    - API gateway (259)
    - Backends for frontends (265)
  - Testing patterns:
    - Consumer-driven contract test (302)
    - Consumer-side contract test (303)
    - Service component test (335)
  - Security patterns:
    - Access token (354)
  - Cross-cutting concerns patterns:
    - Externalized configuration (361)
    - Microservice chassis (379)
  - Observability patterns:
    - Application metrics (373)
    - Audit logging (377)
    - Distributed tracing (370)
    - Exception tracking (376)
    - Health check API (366)
    - Log aggregation (368)
  - Deployment patterns:
    - Deploy a service as a container (393)
    - Deploy a service as a VM (390)
    - Language-specific packaging format (387)
    - Service mesh (380)
    - Serverless deployment (416)
    - Sidecar (410)
  - Refactoring to microservices patterns:
    - Anti-corruption layer (447)
    - Strangler application (432)
- 

- Strangler app: new app consisting of microservices, developed by implementing new functionality as services
and extracting services from the monolith

# Arguments
## Preface
- Enterprise applications are typically large monoliths (is it?)

## 1. Escaping monolithic hell
- Monolithic architecture:
  - <img src="../resources/microservices-patterns/1.1.png" alt="drawing" width="500"/>
  - Suitable for new, small app
  - Benefits when the app is small:
    - Simple to dev: suitable for IDE & dev tools
    - Easy to make radical changes
    - Easy to test
    - Easy to deploy
    - Easy to scale
  - Drawbacks when the app is big:
    - Too complex -> difficult to dev & debug
    - Dev is slow: lag IDE, slow build, long start up time -> edit, build, run, test loop takes a long time
    - Path from commit to deployment is long:
      - Many devs -> hard to merge & need further testing
      - Complex -> need careful, system testing
    - Difficult to scale: conflicting resource requirements from dif modules
    - Not reliable:
      - Hard to test thoroughly
      - Lack of fault isolation
    - Locked into an obsolete tech stack: rewrite whole app is risky
- Software architecture mainly affect nonfunctional requirements (maintainability, extensibility, testability), not functional requirements
- 3 ways to scale an app:
  - Load balance requests across multiple instances:
    - Randomly
    - Based on request's attribute
  - Decompose by function into multiple services. Can be combined with load balancing.
- Microservice architecture:
  - <img src="../resources/microservices-patterns/1.7.png" alt="drawing" width="500"/>
  - Suitable for large, complex app
  - -> Less about size, more about clear, focused responsibility for each service
  - Characteristics:
    - Loosely coupled services: services as unit of modularity, API as boundary
    - -> Easier to preserve modularity
    - Services communicate via APIs
    - Each service has its own database
  - Benefits: of small, independent services:
    - Enables the continuous delivery and deployment of large, complex apps (most imp benefit):
      - Testability
      - Deployability: usually don't require coordination
      - Autonomous, loosely coupled teams
    - Maintainability
    - Scalability: based on resource requirement of each service
    - Easy to experiment & adopt new techs
    - Reliability:
      - Better fault isolation
      - Easier to test
  - Drawbacks:
    - Difficult to find the right set of services
    - -> Can result in distributed monolith
    - Complex distributed system:
      - IPC
      - Partial failures
      - Transactions & queries spanning multiple services
      - Dev: not supported by IDE, hard to do automated testing multiple services
      - Operational complexity: management & deployment
    - -> Require sophisticated dev & operation skills
    - Need coordination when deploying features spanning many services
    - Difficult to decide when to adopt
  -> Many issues has multiple solutions, each with different set of tradeoffs
- Pattern:
  - Describe:
    - Issues
    - Result:
      - Benefit: solved issues
      - Drawback: unsolved issues
      - New issues
    - Related patterns
  - -> Objectivity -> better decision making
  - Can be organized into group: handle problems in a particular area
  - Pattern language: collection of related patterns that solve problems within a particular domain
- Microservice pattern language:
  - Software pattern: solves a software architecture or design problem by defining a set of collaborating software elements:
    - Object-oriented pattern: contains collaborating classes
    - High level design pattern: contains collaborating services
  - 3 layers:
    - Infra patterns: solve infra issues outside development
    - App infra patterns: solve infra issues related to development
    - App patterns: solve development problems
  - <img src="../resources/microservices-patterns/1.10.png" alt="drawing" width="500"/>
  - Groups:
    - Decomposition:
    - <img src="../resources/microservices-patterns/1.11.png" alt="drawing" width="500"/>
    - Communication:
    - <img src="../resources/microservices-patterns/1.12.png" alt="drawing" width="500"/>
    - Data consistency:
    - <img src="../resources/microservices-patterns/1.13.png" alt="drawing" width="500"/>
    - Data query:
    - <img src="../resources/microservices-patterns/1.14.png" alt="drawing" width="500"/>
    - Deployment:
    - <img src="../resources/microservices-patterns/1.15.png" alt="drawing" width="500"/>
    - Observability
    - Automated testing
    - Crosscutting concerns
    - Security
- Process & organization:
  - Imp for success, beside architecture
  - <img src="../resources/microservices-patterns/1.16.png" alt="drawing" width="500"/>
  - Organization: team of teams, each 8-12 people
    - Each team has clear business-oriented goal:
    developing and possibly operating one or more services that implement a feature or a business capability
    - Cross-functional, can develop, test, and deploy its services without having to frequently communicate or coordinate with other teams
    - Grow: adding teams
  - -> Higher dev velocity, clear point of contact
  - Development & delivery process: agile dev & deployment practices (eg Scrum, Kanban)
  - Transition from monolithic to microservice architecture: need to consider reaction & emotion of people

## 2. Decomposition strategies

## 13. Refactoring to microservices
- Goal: refactor from monolith to microservices without having to rewrite app from scratch
### Overview of refactoring to microservices
- Consideration before refactoring: make sure business problems arise because of monolith architecture, not because of:
  - Poor software dev process (eg manual testing)
  - Not try all scalability solution
- Non-strategy: dev new microservices app from scratch. Reasons:
  - Lots of time wasted not implementing features that the business needs
  - New features still developed in the monolith -> effort diverted, constant moving target
  - Might implement features that are no longer needed
- Overall strat:
  - Incrementally refactor the monolith & build stranger app
  - -> Stop when the monolith is small enough/no longer an obstacle to ongoing dev
  - Migrate high value or constantly changing areas of the app first
  - -> Increase dev velocity, maintain business support for the migration
  - Avoid making widespread changes to the monolith
  - Avoid building deployment infra upfront: only need a deployment pipeline with automated testing
  - Reduce effort, have time to gain real exp to pick technologies
### Strategies for refactoring a monolith to microservices
- Implement new features as services:
  - Benefits:
    - Stop the monolith from growing
    - Accelerate dev of new features
    - Demonstrate business value
  - Need 2 other elements to integrate the new service into the app:
    - API gateway: to route request to service & monolith
    - Integration glue code:
      - Allow service to access the monolith data & invoke its functionality
      - Consist of adapters in the monolith & the service that communicate via IPC
    - IMG 13.2
  - Non-usage:
    - New feature is too small to be a meaningful service
    - New feature is too tightly coupled with the monolith
    - -> Performance problem due to excessive IPC
    - Data consistency problem
  - -> Need to implement in the monolith, extract later
- Separate presentation tier from the backend:
  - IMG 13.3
  - Benefits:
    - Dev, deploy & scale 2 apps independently
    - Expose remote API of monolith that can be called by new microservices
  - -> Only a partial solution
- Extract business capabilities into services:
  - IMG 13.4
  - Parts to extract to the new service:
    - Inbound adapters containing API endpoints
    - Domain logic
    - Outbound adapters (eg DB access logic)
    - DB schema of the monolith
  - Likely to be time-consuming: monolith code base is likely to be messy
  - -> Need to decide which service to extract first
  - Might do over many iterations: each iteration extract several functionalities
  - Design issues:
    - How to split the domain model:
      - Remove object references:
        - Use aggregate concept
        - Avoid having large impact on clients of the class on the monolith: replicate data
      - Split class: extract functionality from a class that has other responsibilities
    - How to refactor the database: changing all clients of the DB to use the new schema takes lots of time
    - -> Solutions:
      - Migrate then replicate data from service back to monolith to avoid large impact
      - Migrate the clients incrementally (might not need to when client code is extracted into a new service)
    - What is the sequence of service extraction:
      - Design the new architecture -> revise it as you gain migration experience
      - Strats:
        - Freeze monolith dev/bug fix and extract services on demand:
          - Adv: force you to break up the monolith
          - Disadv: service extraction is driven by short-term requirements
          - -> Risk of small benefit in exchange for lots of effort
        - Rank services by the benefit from extraction:
          - Accelerates development: when business roadmap suggests lots of dev in such part
          - Solve performance/scaling/reliability problem
          - Enable extraction of other services
        - -> More strategic & closely align with business' needs
  - Design steps:
    - Review code related to the service business and identify participating entities & their fields
    - Decide which data to migrate to the service. Need to consider:
      - How monolith and service access each other's data
      - How to maintain data consistency
    - Design service domain logic: mostly copy code from the monolith
### Designing how the service and the monolith collaborate
- Design integration glue:
  - Design API that the glue provides to the domain logic: encapsulate in an interface:
    - Query API: Respository interface
    - Command API: Service interface:
      - Changes in the monolith to call the Service interface:
        - Identify all places in the monolith that invoke such business logic to call the interface
        - Implement the interface with:
          - Existing monolith logic
          - Proxy to new service
        - Use feature toggle to dynamically switch between the 2 implementations
        - Remove the existing monolith implementation when the service is considered working as expected
        - IMG 13.23
  - Pick interaction style & IPC mechanism:
    - Query data:
      - Option 1: consumer invoke RPC API of data provider:
        - Adv: simple to implement
        - Disadv:
          - Inefficient if consumer makes lots of requests
          - Reduced availability
      - Option 2:
        - Provider is monolith: service implement CQRS
        - Provider is service: service publish domain events for monolith to consume and update its DB
        - Adv: efficient
        - Disadv:
          - Increased complexity
          - Might need to modify monolith to publish domain event
    - Update data: use transactional messaging
      - Transaction required: use saga
      - Transaction not required: publish event
  - Implement anti-corruption layer:
    - When:
      - Develop new domain model in the service, dif from monolith domain model
      - Need to communicate with monolith
    - Goal: prevent legacy monolith's domain model from polluting service's domain model
    - Anti corruption layer def: layer of code that translates between dif domain models
    - IMG 13.11
    - Functions:
      - Map class/attribute names/values
      - Map status code
    - Where to implement:
      - In service:
        - When receive monolith domain event
        - When invoke monolith API
      - In monolith:
        - When subscribe to service event
        - When invoke service API
  - Publish/consume domain event in the monolith:
    - Publish:
      - Sol 1: in the code:
        - Adv: can publish high level domain event
        - Disadv:
          - Need to locate all the places to publish. Potentially huge change.
          - Can't deal with cases using stored procedure
      - Sol 2: use DB event via transaction log tailing/polling
        - Adv: don't have to change the monolith
        - Disadv:
          - Low level event
          - Don't know reason for the update
    - Consume problem: monolith written in language without message broker client
    - -> New helper service to subscribe to event & update monolith DB directly
- Maintain data consistency across service and monolith:
  - Problem: introducing saga's compensating transaction in the monolith might require numerous, risky code change (eg new "state" field in DB model)
  - Approach: ensure monolith transactions are either pivot or retriable transactions by:
    - Design saga
    - Decide service extraction order
- Handle authentication & authorization:
  - Problem: support both monolith and JWT-based security mechanisms simultaneously
  - Solution:
    - Monolith login handler returns an additional cookie to be included in every request. Cookie content: JWT token.
    - API gateway validate the token in the cookie, set it in authorization header and send to services
    - Services validate the token and extract info
    - IMG 13.13
### Refactoring examples of strat 1 and 3: skipped

# Criticism
- Chap 13:
  - Why place anti-corruption layer in service? Should keep the service adapter clean for new usages.

# Take away
- Lots of architectural concepts, problems & solutions
- -> Deeper understanding of system design, microservice concepts, design issues & dif solutions
- -> Bring out all relevant exp to reflect
- Modern technologies & frameworks to consider/experiment with

# S's problems when migrate from the monolith to microservices
- Split the services horizontally instead of vertically
- -> Compromise transaction isolation. Services depend on each other.
- Keep the account database schema instead of refactoring it